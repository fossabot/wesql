#
# Test for binlog archive to object store.
#
--echo # Binlog persist to object store

CREATE DATABASE db1;
CREATE TABLE t1(c1 int, c2 char(200)) ENGINE=SMARTENGINE ;
INSERT INTO t1 values(1,'abcd');
INSERT INTO t1 values(2,'abcd');
INSERT INTO t1 values(3,'abcd');
INSERT INTO t1 values(4,'abcd');
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
FLUSH logs;
INSERT INTO t1 values(5,'abcd');
FLUSH logs;
FLUSH logs;
FLUSH logs;
INSERT INTO t1 values(6,'abcd');
INSERT INTO t1 values(7,'abcd');
INSERT INTO t1 values(8,'abcd');
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
FLUSH logs;

SELECT count(*) FROM t1;
SHOW CREATE TABLE t1;

--source include/show_binary_logs.inc

sleep 1;

SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILE_INDEX;
--disable_warnings
SELECT Log_slice_key from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILES order by Log_slice_key;
--enable_warnings

--let logfile = query_get_value(SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILE_INDEX order by Log_name, Log_name, 2)
--echo # Puge persistent binlog $logfile
--eval SELECT binlog_persistent_purge('$logfile')

SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILE_INDEX order by Log_name;
--disable_warnings
SELECT Log_slice_key from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILES order by Log_slice_key;
--enable_warnings
--source include/show_binary_logs.inc

DROP TABLE t1;
DROP DATABASE db1;

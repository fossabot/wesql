#
# Test for binlog archive to object store.
#
--echo # Binlog persist to object store

--echo # Wait for first binlog persistent after startup 
let $wait_condition= SELECT count(distinct Log_name) = 1 FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILE_INDEX;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILE_INDEX;
--disable_warnings
SELECT Log_slice_key from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILES order by Log_slice_key;
--enable_warnings

CREATE DATABASE db1;
CREATE TABLE t1(c1 int, c2 char(200)) ENGINE=SMARTENGINE ;
INSERT INTO t1 values(1,'abcd');
INSERT INTO t1 values(2,'abcd');
INSERT INTO t1 values(3,'abcd');
INSERT INTO t1 values(4,'abcd');
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
FLUSH logs;
INSERT INTO t1 values(5,'abcd');
FLUSH logs;
FLUSH logs;
FLUSH logs;
INSERT INTO t1 values(6,'abcd');
INSERT INTO t1 values(7,'abcd');
INSERT INTO t1 values(8,'abcd');
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
FLUSH logs;

SELECT count(*) FROM t1;
SHOW CREATE TABLE t1;

--source include/show_binary_logs.inc

sleep 1;

SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILE_INDEX;
--disable_warnings
SELECT Log_slice_key from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILES order by Log_slice_key;
--enable_warnings

let $wait_condition= SELECT last_persistent_binlog_pos = last_persistent_binlog_write_pos FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_INFO;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

--echo #Rotate forbidden in transaction
set global debug= '+d, force_rotate_forbidded';

BEGIN;
INSERT INTO t1 SELECT * FROM t1 limit 100;
COMMIT;
BEGIN;
INSERT INTO t1 SELECT * FROM t1 limit 100;
COMMIT;
BEGIN;
INSERT INTO t1 SELECT * FROM t1 limit 100;
COMMIT;

let $wait_condition= SELECT last_persistent_binlog_write_pos > last_persistent_binlog_pos  FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_INFO;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

set global debug= '-d, force_rotate_forbidded';

let $wait_condition= SELECT last_persistent_binlog_pos = last_persistent_binlog_write_pos FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_INFO;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

--disable_warnings
SELECT Log_slice_key from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILES order by Log_slice_key;
--enable_warnings

--let logfile = query_get_value(SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILE_INDEX order by Log_name, Log_name, 2)
--echo # Puge persistent binlog $logfile
--eval SELECT binlog_persistent_purge('$logfile')

SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILE_INDEX order by Log_name;
--disable_warnings
SELECT Log_slice_key from INFORMATION_SCHEMA.BINLOG_PERSISTENT_FILES order by Log_slice_key;
--enable_warnings

--source include/show_binary_logs.inc

DROP TABLE t1;
DROP DATABASE db1;

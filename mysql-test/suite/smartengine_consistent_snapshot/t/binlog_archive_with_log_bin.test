#
# Test for binlog archive to object store.
#
--echo # Binlog persist to object store
--echo # Wait for first binlog persistent after startup 
let $wait_condition= SELECT count(distinct Log_name) = 1 FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICE_INDEX;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

CREATE DATABASE db1;
CREATE TABLE t1(c1 int, c2 char(200)) ENGINE=SMARTENGINE ;
INSERT INTO t1 values(1,'abcd');
INSERT INTO t1 values(2,'abcd');
INSERT INTO t1 values(3,'abcd');
INSERT INTO t1 values(4,'abcd');
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
FLUSH logs;
INSERT INTO t1 values(5,'abcd');
FLUSH logs;
FLUSH logs;
FLUSH logs;
INSERT INTO t1 values(6,'abcd');
INSERT INTO t1 values(7,'abcd');
INSERT INTO t1 values(8,'abcd');
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;

SELECT count(*) FROM t1;

--source include/show_binary_logs.inc

--echo # Wait for all binlog persistent
let $wait_condition= SELECT count(*) = 1 FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_INFO, INFORMATION_SCHEMA.WESQL_CLUSTER_LOCAL where LAST_CONSENSUS_INDEX = COMMIT_INDEX;
let $wait_timeout= 600;
# --source include/wait_condition_or_abort.inc

# SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICE_INDEX;
# --disable_warnings
# SELECT SUBSTRING_INDEX(Log_slice_key, '/', -1) from INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICES order by Log_slice_key;
# --enable_warnings

DROP TABLE t1;
DROP DATABASE db1;

#
# Test for binlog archive to object store.
#
--echo # Binlog persist to object store

--echo # Wait for first binlog persistent after startup 
let $wait_condition= SELECT count(distinct Log_name) = 1 FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICE_INDEX;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICE_INDEX;
--disable_warnings
SELECT SUBSTRING_INDEX(Log_slice_key, '/', -1) from INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICES order by Log_slice_key;
--enable_warnings

CREATE DATABASE db1;
CREATE TABLE t1(c1 int, c2 char(200)) ENGINE=SMARTENGINE ;
INSERT INTO t1 values(1,'abcd');
INSERT INTO t1 values(2,'abcd');
INSERT INTO t1 values(3,'abcd');
INSERT INTO t1 values(4,'abcd');
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
FLUSH logs;
INSERT INTO t1 values(5,'abcd');
FLUSH logs;
FLUSH logs;
FLUSH logs;
INSERT INTO t1 values(6,'abcd');
INSERT INTO t1 values(7,'abcd');
INSERT INTO t1 values(8,'abcd');
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;
INSERT INTO t1 SELECT * FROM t1;

SELECT count(*) FROM t1;
SHOW CREATE TABLE t1;

# --source include/show_binary_logs.inc

--echo # Wait for all binlog persistent
let $wait_condition= SELECT count(*) = 1 FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_TASK_INFO, INFORMATION_SCHEMA.WESQL_CLUSTER_LOCAL where LAST_PERSISTED_RAFT_INDEX = COMMIT_INDEX;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

# SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICE_INDEX;
# --disable_warnings
# SELECT SUBSTRING_INDEX(Log_slice_key, '/', -1) from INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICES order by Log_slice_key;
# --enable_warnings

let $wait_condition= SELECT LAST_PERSISTED_BINLOG_POS = LAST_PERSISTING_BINLOG_WRITE_POS FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_TASK_INFO;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

--echo #Rotate forbidden in transaction
set global debug= '+d, force_rotate_forbidded';

BEGIN;
INSERT INTO t1 SELECT * FROM t1 limit 100;
COMMIT;
BEGIN;
INSERT INTO t1 SELECT * FROM t1 limit 100;
COMMIT;
BEGIN;
INSERT INTO t1 SELECT * FROM t1 limit 100;
COMMIT;

let $wait_condition= SELECT LAST_PERSISTING_BINLOG_WRITE_POS > LAST_PERSISTING_BINLOG_POS  FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_TASK_INFO;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

--echo #Rotate allowed
set global debug= '-d, force_rotate_forbidded';

let $wait_condition= SELECT LAST_PERSISTING_BINLOG_WRITE_POS = LAST_PERSISTED_BINLOG_POS FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_TASK_INFO;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

# --disable_warnings
# SELECT SUBSTRING_INDEX(Log_slice_key, '/', -1) from INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICES order by Log_slice_key;
# --enable_warnings

--let logfile = query_get_value(SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICE_INDEX order by Log_name, Log_name, 2)
--echo # Puge persistent binlog $logfile
--eval SELECT binlog_persistent_purge('$logfile')

# SELECT distinct Log_name from INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICE_INDEX order by Log_name;
# --disable_warnings
# SELECT SUBSTRING_INDEX(Log_slice_key, '/', -1) from INFORMATION_SCHEMA.BINLOG_PERSISTENT_SLICES order by Log_slice_key;
# --enable_warnings

# --source include/show_binary_logs.inc

--echo # Wait for all binlog persistent
let $wait_condition= SELECT count(*) = 1 FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_TASK_INFO, INFORMATION_SCHEMA.WESQL_CLUSTER_LOCAL where LAST_PERSISTED_RAFT_INDEX = COMMIT_INDEX;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

--let $error_log=$MYSQLTEST_VARDIR/log/mysqld.1.err

# fault_injection_add_slice_queue
--echo # fault_injection_add_slice_queue 
set global debug= '+d, fault_injection_add_slice_queue';

INSERT INTO t1 values(1,'abcd');
INSERT INTO t1 values(2,'abcd');
INSERT INTO t1 values(3,'abcd');
INSERT INTO t1 values(4,'abcd');

--sleep 3

--let $grep_file=$error_log
--let $grep_pattern=fault_injection_add_slice_queue
--let $grep_output=boolean
--source include/grep_pattern.inc

--let $grep_file=$error_log
--let $grep_pattern=persistent abort
--let $grep_output=boolean
--source include/grep_pattern.inc

set global debug= '-d, fault_injection_add_slice_queue';

--echo # Wait for all binlog persistent
let $wait_condition= SELECT count(*) = 1 FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_TASK_INFO, INFORMATION_SCHEMA.WESQL_CLUSTER_LOCAL where LAST_PERSISTED_RAFT_INDEX = COMMIT_INDEX;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

# fault_injection_put_slice_to_objstore
--echo # fault_injection_put_slice_to_objstore 
set global debug= '+d, fault_injection_put_slice_to_objstore';

INSERT INTO t1 values(1,'abcd');
INSERT INTO t1 values(2,'abcd');
INSERT INTO t1 values(3,'abcd');
INSERT INTO t1 values(4,'abcd');

--echo # Wait for all binlog add expected persistent queue.
let $wait_condition= SELECT count(*) = 1 FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_TASK_INFO, INFORMATION_SCHEMA.WESQL_CLUSTER_LOCAL where LAST_PERSISTING_RAFT_INDEX = COMMIT_INDEX;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

--sleep 3

--let $grep_file=$error_log
--let $grep_pattern=fault_injection_put_slice_to_objstore
--let $grep_output=boolean
--source include/grep_pattern.inc

--let $grep_file=$error_log
--let $grep_pattern=binlog slice persisted failed
--let $grep_output=boolean
--source include/grep_pattern.inc

--let $grep_file=$error_log
--let $grep_pattern=check found update index failed
--let $grep_output=boolean
--source include/grep_pattern.inc

set global debug= '-d, fault_injection_put_slice_to_objstore';

--echo # Wait for all binlog persistent
let $wait_condition= SELECT count(*) = 1 FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_TASK_INFO, INFORMATION_SCHEMA.WESQL_CLUSTER_LOCAL where LAST_PERSISTED_RAFT_INDEX = COMMIT_INDEX;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

# fault_injection_binlog_archive_update_index_file
--echo # fault_injection_binlog_archive_update_index_file 
set global debug= '+d, fault_injection_binlog_archive_update_index_file';

INSERT INTO t1 values(1,'abcd');
INSERT INTO t1 values(2,'abcd');
INSERT INTO t1 values(3,'abcd');
INSERT INTO t1 values(4,'abcd');

--sleep 3

--let $grep_file=$error_log
--let $grep_pattern=fault_injection_binlog_archive_update_index_file
--let $grep_output=boolean
--source include/grep_pattern.inc

--let $grep_file=$error_log
--let $grep_pattern=check found update index failed
--let $grep_output=boolean
--source include/grep_pattern.inc

set global debug= '-d, fault_injection_binlog_archive_update_index_file';

--echo # Wait for all binlog persistent
let $wait_condition= SELECT count(*) = 1 FROM INFORMATION_SCHEMA.BINLOG_PERSISTENT_TASK_INFO, INFORMATION_SCHEMA.WESQL_CLUSTER_LOCAL where LAST_PERSISTED_RAFT_INDEX = COMMIT_INDEX;
let $wait_timeout= 600;
--source include/wait_condition_or_abort.inc

DROP TABLE t1;
DROP DATABASE db1;
